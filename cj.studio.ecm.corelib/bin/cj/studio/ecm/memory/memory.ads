----------------------------------------------------------------------------------------------------------
--------------扩展名为ads的文件为设计说明书的缩写，Architectural Design Specification--------
------------------------------------共享内存算法（cjm），即摸拟C++对象内存申请、引用、释放过程-----------------------------------------------------------------------
---------------------------------------著作权所有者：赵向彬 C.J----------------------------------------------------------------------

	1.以java的哈稀代表对象句柄，new对象，释放对象。如：new Object()该对象实现某某接口，接口中具有point指针
		通过point指针可以从内存中引用对象，如：point.refrence(),即得到对象引用，point.dispose()即从内存中删除对象
		如果创建的对象在内存中不存在则状态为point.isNew即新申请的对象，point.isRefernce则为从内存中恢复的对象
	2.所谓内存，包括三个方面：
		1）以操作系统文件作为内存介质，如同windows的page.sys，限定到操作系统，但可跨平台部署
		2）以java静态数组作为介质，内存的操作被限定在java进程内
		3）以jni方式作为介质，通过调用本地操作系统内存设备申请内存，真正意义上的内存介质。限定到一个操作系统
		
		以上三种介质，对于cjm来讲，cjm只认字节数组，cjm把不同介质分成内存页映像，内存页的持久对介质一视同仁，全为字节
	
	说明：鉴于复杂度和应用的广泛性，共享内存和云存储应单独成project
	
	原理：Java为每个对象分配一个哈希，哈希代表java对象在内存中的位置抽象，而对于字符串的哈希，java中是唯一的，不重复的。
		所以可以用哈希来做对象的指针。如在cjm中，我在一个进程内用字符串生成了个指针，"127.0.0.1:800".hash=232323
		以这个来存了个对象，在另一进程中想使用此对象，只需要point p=new point(232323);PObject obj=p.reference()即可得到，用完释放：obj.disponse();
		
	
	算法概要：
		1.将来的云计算本来也要做页的结构，cjm可为初步尝试。cjm只有一个足够大的定长页，该页分为行，每个对象一行，
			不限长度，由上至下，在页脚从左往右写列（或叫槽），每列描述一行，列的大定固定。从而形成一个矩阵。
			写的时候，对象数据从上个对象尾添加，向下写，列却是往前写，剂到中间某个长度，说明内存已满，或者整理无效的行。
			在写的时候也可以检查对象大小，如果某个列已标为删除的且大小可容，则写互此处。该算法不擦除数据，而是标记列为写可用即可
			列在读的时候一次读到内存，通过哈希map定位到列
		2.列的格式：
			应包括，对象的句柄（哈希）int4字节、对象在页中地址（3字节由此决定页大小），对象的偏移量（short）决定最大大小，
			列最上面的1个字节为状态，其0位表示对象是否可用，不可用即被删除了，1位表示是否加锁，最高两位为10，表明是列。
			其余的位预留
		3.如果考虑将来的云存储，应支持多页，比如索引页采用倒排算法，查寻对象句柄（哈希int）分布到哪些页中，
			在云存储中，一个对象其拷贝或者其片段可能分布到多个页中，故而索引的每行应有相应描述。而索引行的索引为列（槽），
			每个索引列根据窗口来缩下范围，因为在应用层每个对象都预定一个哈希整数，这个数便落在范围之内，由某个范围，知道在哪个索引页
			由索引项的倒排，知道在哪个数据页，由此定位到对象。
			可考虑通用化对象指针（或句柄），不一定用哈稀。